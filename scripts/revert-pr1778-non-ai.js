#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';
import { execSync } from 'child_process';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

const PR_COMMIT = 'f5205799';

function hasAIImagery(attribution) {
  if (!attribution) return false;
  const lower = attribution.toLowerCase();
  return lower.includes('midjourney') ||
         lower.includes('chatgpt') ||
         lower.includes('dall-e') ||
         lower.includes('deepai') ||
         lower.includes('stable diffusion') ||
         lower.includes('artificial intelligence') ||
         lower.includes('ai generated') ||
         (lower.includes('generated by') && (lower.includes('ai') || lower.includes('chatgpt') || lower.includes('midjourney'))) ||
         lower.includes('gemini') ||
         lower.includes('myninja');
}

function getGameFilesFromPR() {
  const output = execSync(`git show ${PR_COMMIT} --name-only --format=`, { encoding: 'utf8' });
  const files = output.trim().split('\n').filter(f => f.endsWith('.json') && f.includes('library/games/'));
  return files;
}

function getGameInfoBeforePR(gameFile) {
  try {
    const output = execSync(`git show ${PR_COMMIT}^:"${gameFile}"`, { encoding: 'utf8' });
    const game = JSON.parse(output);
    return {
      image: game._meta?.info?.image,
      attribution: game._meta?.info?.attribution
    };
  } catch (error) {
    return null;
  }
}

function getGameInfoAfterPR(gameFile) {
  try {
    const output = execSync(`git show ${PR_COMMIT}:"${gameFile}"`, { encoding: 'utf8' });
    const game = JSON.parse(output);
    return {
      image: game._meta?.info?.image,
      attribution: game._meta?.info?.attribution
    };
  } catch (error) {
    return null;
  }
}

function getAssetPath(imagePath, gameFile) {
  if (!imagePath || !imagePath.startsWith('/assets/')) return null;
  const assetName = imagePath.replace('/assets/', '');
  const gameDir = path.dirname(gameFile);
  return path.join(gameDir, 'assets', assetName);
}

function revertGameFile(gameFile) {
  try {
    const beforePR = getGameInfoBeforePR(gameFile);
    if (!beforePR) return { reverted: false, oldImage: null, newImage: null };

    const afterPR = getGameInfoAfterPR(gameFile);
    if (!afterPR) return { reverted: false, oldImage: null, newImage: null };

    const content = fs.readFileSync(gameFile, 'utf8');
    const game = JSON.parse(content);
    
    if (!game._meta || !game._meta.info) {
      return { reverted: false, oldImage: null, newImage: null };
    }

    const oldImage = beforePR.image;
    const newImage = afterPR.image;
    const currentImage = game._meta.info.image;
    const currentAttribution = game._meta.info.attribution;
    const hasAIFlag = game._meta.info.usesAIImagery === true;
    
    const changed = currentImage !== oldImage || 
                   currentAttribution !== beforePR.attribution ||
                   hasAIFlag;

    if (changed) {
      game._meta.info.image = oldImage;
      game._meta.info.attribution = beforePR.attribution;
      if (game._meta.info.usesAIImagery !== undefined) {
        delete game._meta.info.usesAIImagery;
      }
      fs.writeFileSync(gameFile, JSON.stringify(game, null, 2) + '\n', 'utf8');
      return { reverted: true, oldImage, newImage };
    }
    
    return { reverted: false, oldImage, newImage };
  } catch (error) {
    console.error(`Error reverting ${gameFile}:`, error.message);
    return { reverted: false, oldImage: null, newImage: null };
  }
}

function restoreOldImage(gameFile, oldImagePath) {
  if (!oldImagePath) return false;
  
  const oldAssetPath = getAssetPath(oldImagePath, gameFile);
  if (!oldAssetPath) return false;

  // Check if old image exists and has content
  if (fs.existsSync(oldAssetPath)) {
    const stats = fs.statSync(oldAssetPath);
    if (stats.size > 0) {
      return false; // Already exists with content
    }
    // File exists but is empty, remove it so we can restore
    try {
      fs.unlinkSync(oldAssetPath);
    } catch (error) {
      // Ignore
    }
  }

  // Ensure assets directory exists
  const assetsDir = path.dirname(oldAssetPath);
  if (!fs.existsSync(assetsDir)) {
    fs.mkdirSync(assetsDir, { recursive: true });
  }

  // Try to restore from git
  try {
    const gameDir = path.dirname(gameFile);
    const assetName = path.basename(oldAssetPath);
    const gameDirRelative = gameFile.replace(/^library\/games\//, '').replace(/\/[^\/]+\.json$/, '');
    const gitPath = `${PR_COMMIT}^:"library/games/${gameDirRelative}/assets/${assetName}"`;
    
    execSync(`git show ${gitPath} > "${oldAssetPath}"`, { encoding: 'utf8', stdio: 'pipe' });
    
    // Verify it was restored
    if (fs.existsSync(oldAssetPath) && fs.statSync(oldAssetPath).size > 0) {
      return true;
    }
    return false;
  } catch (error) {
    // Old image might not have existed or might be in a different location
    return false;
  }
}

function removeNewImage(gameFile, newImagePath) {
  if (!newImagePath) return false;
  
  const newAssetPath = getAssetPath(newImagePath, gameFile);
  if (!newAssetPath) return false;

  // Only remove if it exists and is different from old image
  if (fs.existsSync(newAssetPath)) {
    try {
      fs.unlinkSync(newAssetPath);
      return true;
    } catch (error) {
      console.error(`Error removing ${newAssetPath}:`, error.message);
      return false;
    }
  }
  
  return false;
}

console.log('Checking games changed in PR 1778...\n');

const gameFiles = getGameFilesFromPR();
const gamesToRevert = [];
const gamesWithAI = [];

for (const gameFile of gameFiles) {
  const beforePR = getGameInfoBeforePR(gameFile);
  if (!beforePR) continue;

  const hadAI = hasAIImagery(beforePR.attribution);
  
  if (hadAI) {
    gamesWithAI.push(gameFile);
  } else {
    gamesToRevert.push(gameFile);
  }
}

console.log(`Games that HAD AI imagery before PR 1778 (${gamesWithAI.length}):`);
gamesWithAI.forEach(f => console.log(`  - ${f}`));

console.log(`\nGames that did NOT have AI imagery before PR 1778 (${gamesToRevert.length}):`);
gamesToRevert.forEach(f => console.log(`  - ${f}`));

console.log(`\nReverting library image, attribution, and AI flag for ${gamesToRevert.length} games...\n`);

let reverted = 0;
let imagesRestored = 0;
let imagesRemoved = 0;
let flagsRemoved = 0;

for (const gameFile of gamesToRevert) {
  const beforePR = getGameInfoBeforePR(gameFile);
  const afterPR = getGameInfoAfterPR(gameFile);
  
  if (!beforePR || !afterPR) continue;
  
  const result = revertGameFile(gameFile);
  if (result.reverted) {
    reverted++;
    console.log(`Reverted: ${gameFile}`);
  }
  
  // Always try to restore old image and remove AI image, even if JSON was already correct
  if (beforePR.image && restoreOldImage(gameFile, beforePR.image)) {
    imagesRestored++;
    console.log(`  Restored old image: ${beforePR.image}`);
  }
  
  if (afterPR.image && afterPR.image !== beforePR.image && removeNewImage(gameFile, afterPR.image)) {
    imagesRemoved++;
    console.log(`  Removed AI image: ${afterPR.image}`);
  }
  
  // Also check and remove usesAIImagery flag if present
  try {
    const content = fs.readFileSync(gameFile, 'utf8');
    const game = JSON.parse(content);
    if (game._meta?.info?.usesAIImagery === true) {
      delete game._meta.info.usesAIImagery;
      fs.writeFileSync(gameFile, JSON.stringify(game, null, 2) + '\n', 'utf8');
      flagsRemoved++;
      console.log(`  Removed usesAIImagery flag from ${gameFile}`);
    }
  } catch (error) {
    // Ignore
  }
}

console.log(`\nDone!`);
console.log(`  - Reverted ${reverted} game file(s)`);
console.log(`  - Removed ${flagsRemoved} usesAIImagery flag(s)`);
console.log(`  - Restored ${imagesRestored} old image(s)`);
console.log(`  - Removed ${imagesRemoved} AI image(s)`);
