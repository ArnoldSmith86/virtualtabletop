/* helper functions generated by ChatGPT */

function positionElementsInArc(elements, radius, arcAngle, container) {
  const n = elements.length;
  const middleIndex = Math.floor(n / 2);

  for (let i = 0; i < n; i++) {
    const angle = (arcAngle / (n - 1)) * (i - middleIndex);
    const radians = (Math.PI / 180) * angle;
    const x = container.clientWidth / 2 + radius * Math.sin(radians) - elements[i].offsetWidth / 2;
    const y = container.clientHeight / 2 + (radius - elements[i].offsetHeight / 2) * (1 - Math.cos(radians));

    elements[i].style.position = 'absolute';
    elements[i].style.left = `${x}px`;
    elements[i].style.top = `${y-100}px`;
    elements[i].style.transform = `rotate(${angle}deg)`;
    elements[i].style.zIndex = (i === middleIndex ? n : n - Math.abs(i - middleIndex));
  }
}

function shuffleArray(array) {
  for (let i = array.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [array[i], array[j]] = [array[j], array[i]];
  }
  return array;
}

function getBoundingClientRectWithAbsoluteChildren(element) {
  const rect = element.children.length ? { left: 9999, top: 9999, right: 0, bottom: 0 } : element.getBoundingClientRect();
  let left = rect.left;
  let top = rect.top;
  let right = rect.right;
  let bottom = rect.bottom;

  for(const child of element.children) {
    const childRect = child.getBoundingClientRect();
    left = Math.min(left, childRect.left);
    top = Math.min(top, childRect.top);
    right = Math.max(right, childRect.right);
    bottom = Math.max(bottom, childRect.bottom);
  }

  return {
    left,
    top,
    right,
    bottom,
    width: right - left,
    height: bottom - top
  };
}

function centerElementInClientRect(element, boundingClientRect) {
  const elementRect = getBoundingClientRectWithAbsoluteChildren(element);

  const centerX = boundingClientRect.left + boundingClientRect.width / 2;
  const centerY = boundingClientRect.top + boundingClientRect.height / 2;

  const elementCenterX = elementRect.left + elementRect.width / 2;
  const elementCenterY = elementRect.top + elementRect.height / 2;

  const translateX = centerX - elementCenterX;
  const translateY = centerY - elementCenterY;

  element.style.transform = `translate(${translateX}px, ${translateY}px) ${element.style.transform}`;
}


/* end helper functions */

class PropertiesModule extends SidebarModule {
  constructor() {
    super('tune', 'Properties', 'Edit widget properties.');
  }

  addInput(type, labelText, value, target) {
    const div = document.createElement('div');
    const idPost = Math.random().toString(36).substring(3, 12);

    const label = document.createElement('label');
    label.htmlFor = "propertyModule"+idPost;
    label.textContent = labelText;
    label.style.display = 'inline-block';
    label.style.width = '100px';
    div.appendChild(label);

    (target || this.moduleDOM).append(div);

    if(typeof value != 'object') {
      const input = document.createElement('input');
      input.id = "propertyModule"+idPost;
      input.value = String(value);
      div.appendChild(input);
      return input;
    }
  }

  addPropertyListener(widget, property, updater) {
    updater(widget);

    if(!this.inputUpdaters[widget.id])
      this.inputUpdaters[widget.id] = {};
    if(!this.inputUpdaters[widget.id][property])
      this.inputUpdaters[widget.id][property] = [];

    this.inputUpdaters[widget.id][property].push(v=>updater(widget));
  }

  inputValueUpdated(widget, property, value) {
    if(value.match(/^(-?[0-9]+(\.[0-9]+)?|null|true|false)$/))
      widget.set(property, JSON.parse(value));
    else
      widget.set(property, value);
  }

  onDeltaReceivedWhileActive(delta) {
    for(const widgetID in delta.s)
      if(delta.s[widgetID] && this.inputUpdaters[widgetID])
        for(const property in delta.s[widgetID])
          if(this.inputUpdaters[widgetID][property])
            for(const updater of this.inputUpdaters[widgetID][property])
              updater(delta.s[widgetID][property]);
  }

  onSelectionChangedWhileActive(newSelection) {
    this.moduleDOM.innerHTML = '';
    this.inputUpdaters = {};

    for(const widget of newSelection) {
      this.addHeader(widget.id);
      this.inputUpdaters[widget.id] = {};

      if(widget.get('type') == 'card')
        this.renderCardLayers(widget);
      if(widget.get('type') == 'holder')
        this.renderForHolder(widget);

      for(const property in widget.state) {
        if([ 'id', 'type', 'parent' ].indexOf(property) != -1)
          continue;

        const input = this.addInput('text', property, widget.state[property])
        if(input) {
          if(!this.inputUpdaters[widget.id][property])
            this.inputUpdaters[widget.id][property] = [];

          input.onkeyup = e=>this.inputValueUpdated(widget, property, input.value);
          this.inputUpdaters[widget.id][property].push(v=>input.value=String(v));
        }
      }
    }
  }

  faceObjectInputValueUpdated(deck, face, object, property, value, card, removeObjects) {
    if(value.match(/^(-?[0-9]+(\.[0-9]+)?|null|true|false)$/))
      this.faceTemplates[face].objects[object][property] = JSON.parse(value);
    else
      this.faceTemplates[face].objects[object][property] = value;

    //card.applyDeltaToDOM({ deck: card.get('deck') });
    for(let objectCard=object; objectCard<this.cardLayerCards[face].length; ++objectCard) {
      const oCard = this.cardLayerCards[face][objectCard];
      oCard.domElement.innerHTML = '';
      oCard.createFaces(this.faceTemplates);
      for(let i=0; i<oCard.domElement.children.length; ++i)
        oCard.domElement.children[i].classList.toggle('active', i == oCard.get('activeFace'));
      removeObjects(oCard, objectCard);
    }
  }

  applyFaceTemplateChanges(deck) {
    deck.set('faceTemplates', this.faceTemplates);
  }

  renderCardLayers(widget) {
    const deck = widgets.get(widget.get('deck'));
    const faceTemplates = this.faceTemplates = JSON.parse(JSON.stringify(deck.get('faceTemplates')));

    this.cardLayerCards = [];

    for(const face in faceTemplates) {
      this.cardLayerCards[face] = [];

      if(face == 0)
        this.addHeader('Back face');
      else if(face == 1)
        this.addHeader('Front face');
      else
        this.addHeader(`Face ${face}`);

      for(const object in faceTemplates[face].objects) {
        const objectDiv = document.createElement('div');
        objectDiv.className = 'faceTemplateEdit';

        const card = this.cardLayerCards[face][object] = new Card();
        const newState = {...widget.state};
        newState.activeFace = face;
        this.renderWidget(card, newState, objectDiv);
        const removeObjects = function(card, object) {
          for(const objectDOM of $a(`.active.cardFace .cardFaceObject:nth-child(n+${+object+2})`, card.domElement))
            objectDOM.remove();
        };
        removeObjects(card, object);
        const propsDiv = document.createElement('div');
        propsDiv.className = 'faceTemplateProperty';
        for(const prop in faceTemplates[face].objects[object]) {
          const input = this.addInput('text', prop, faceTemplates[face].objects[object][prop], propsDiv);
          if(input)
            input.onkeyup = e=>this.faceObjectInputValueUpdated(deck, face, object, prop, input.value, card, removeObjects);
        }
        objectDiv.appendChild(propsDiv);
        this.moduleDOM.appendChild(objectDiv);
      }
    }

    const applyButton = document.createElement('button');
    applyButton.innerText = 'Apply changes';
    applyButton.onclick = e=>this.applyFaceTemplateChanges(deck);
    this.moduleDOM.appendChild(applyButton);
  }

  renderForHolder(widget) {
    this.addSubHeader('Target widgets');
    for(const deck of widgetFilter(w=>w.get('type') == 'deck')) {
      const deckButton = this.renderWidgetButton(deck, {}, this.moduleDOM);
      this.addPropertyListener(widget, 'dropTarget', widget=>{
        if(asArray(widget.get('dropTarget')).filter(t=>t.deck == deck.id).length)
          deckButton.classList.add('selected');
        else
          deckButton.classList.remove('selected');
      });
      deckButton.onclick = async e=>{
        let newDropTarget = asArray(widget.get('dropTarget'));
        if(deckButton.classList.contains('selected'))
          newDropTarget = newDropTarget.filter(t=>t.deck != deck.id);
        else
          newDropTarget = newDropTarget.filter(t=>t.type!='card').concat({ deck: deck.id });

        if(newDropTarget.length == 1)
          newDropTarget = newDropTarget[0];
        else if(!newDropTarget.length)
          newDropTarget = null;

        widget.set('dropTarget', newDropTarget);
      };
    }


    this.addSubHeader('Appearance');
    const normal = this.renderWidgetButton(new Holder(), {
      type: 'holder',
      width: 50,
      height: 70
    }, this.moduleDOM);
    const semi = this.renderWidgetButton(new Holder(), {
      type: 'holder',
      width: 50,
      height: 70,
      css: { background: '#fff6' }
    }, this.moduleDOM);
    const transparent = this.renderWidgetButton(new Holder(), {
      type: 'holder',
      width: 50,
      height: 70,
      classes: 'transparent'
    }, this.moduleDOM);

    this.addPropertyListener(widget, 'css', widget=>{
      if(!widget.get('css') && !widget.get('classes'))
        normal.classList.add('selected');
      else
        normal.classList.remove('selected');
    });
    this.addPropertyListener(widget, 'classes', widget=>{
      if(!widget.get('css') && !widget.get('classes'))
        normal.classList.add('selected');
      else
        normal.classList.remove('selected');
    });
    normal.onclick = async e=>{
      if(!normal.classList.contains('selected')) {
        widget.set('classes', null);
        widget.set('css', null);
      }
    };

    this.addPropertyListener(widget, 'css', widget=>{
      if(String(widget.get('css')).includes('#fff6'))
        semi.classList.add('selected');
      else
        semi.classList.remove('selected');
    });
    semi.onclick = e=>{
      if(!semi.classList.contains('selected')) {
        widget.set('classes', null);
        widget.set('css', 'background:#fff6');
      }
    };

    this.addPropertyListener(widget, 'classes', widget=>{
      if(String(widget.get('classes')).includes('transparent'))
        transparent.classList.add('selected');
      else
        transparent.classList.remove('selected');
    });
    transparent.onclick = e=>{
      if(!transparent.classList.contains('selected')) {
        widget.set('classes', 'transparent');
        widget.set('css', null);
      }
    };
  }

  renderWidget(widget, state, target) {
    delete state.id;
    delete state.x;
    delete state.y;
    delete state.rotation;
    delete state.scale;
    delete state.parent;

    widget.applyInitialDelta(state);
    target.appendChild(widget.domElement);
    if(widget instanceof Card)
      widget.deck.removeCard(widget);
    return widget.domElement;
  }

  renderWidgetButton(widget, state, target) {
    const button = document.createElement('button');
    button.className = 'widgetSelectionButton';
    target.appendChild(button);

    if(widget.get('type') == 'deck') {
      const parent = this.renderWidget(new BasicWidget(), {}, button);
      for(const cardType of shuffleArray(Object.keys(widget.get('cardTypes'))).slice(0, 5)) {
        this.renderWidget(new Card(), Object.assign({
          deck: widget.id,
          cardType,
          activeFace: widget.get('faceTemplates').length > 1 ? 1 : 0
        }, state), parent);
      }
      positionElementsInArc(parent.children, parent.children[0].clientHeight, 45, parent);
    } else {
      this.renderWidget(widget, state, button);
    }

    const rect = getBoundingClientRectWithAbsoluteChildren(button.children[0]);
    if(Math.max(rect.width, rect.height) > 140)
      button.children[0].style.transform = `scale(${140/Math.max(rect.width, rect.height)})`;
    centerElementInClientRect(button.children[0], button.getBoundingClientRect());

    return button;
  }

  renderModule(target) {
    target.innerText = 'Properties module not implemented yet.';
  }
}
